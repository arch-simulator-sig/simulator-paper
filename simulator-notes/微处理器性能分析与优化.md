# 微处理器性能分析与优化

## 为什么需要性能分析

1.   流片前：快速搭建模型辅助决策，设计空间探索
2.   流片后：根据实际流完的片改进流片前的模拟器，进行软件相关优化（编译器 os适配）

## 相关背景介绍

### workload介绍

1.   trace : 程序运行时的指令序列、指令地址、数据地址等信息，与处理器细节无关
2.   trace-driven simulator : 将trace作为simulator输入，只需维持控制指令时序的数据
     1.   优点：不需要考虑指令解释，速度较快
     2.   缺点：大的trace需要更多内存，微架构不直接影响程序，建模时引入的错误难以发现，增加了验证工作量
3.   generate trace : 在目标代码中插入额外指令来生成，intel Pin tools
4.   trace方法的优势 : 无需模拟整个微架构就能获得目标workload指标，如 cache miss, inst relationship，bpu miss等
5.   代表性工作 : SPEC CPU2006 workload



### 性能模型设计技术

1.   信号级模型 ： 完全模拟所有硬件单元 （reg , wire, dff, mem) 。 准确，但灵活性和速度拉，修改困难

2.   trace-driven simulator : 见上文

3.   execution-driven simulator : 运行时一边产生trace一边分析，使用function model生成trace

     ```
     trace-driven exec-driven的缺点：
     1. 都cycle by cycle 模拟处理器内部状态，速度和灵活性低
     2. 只建立处理器模型，未建立workload模型
     ```

4.   基于统计的模型 ：概率模型比较麻烦，略

### 加速技术

sampling  （SMARTS算法）

利用统计原理和实际程序运行表现出来的统计特性实现了对误差的估计和控制。对给定的误差范围和置信度，如果采样结果不能满足要求，它能自动推荐很可能满足要求的采样频率。

warmup （减少sampling误差）

保证在开始测量一个样本时，模拟器的微体系结构状态处于正确或者基本正确的状态。一种预热方法是在开始测量前先详细模拟一段指令，如何决定这段指令的长短和预热误差是关键问题。

simpoint

先完整地运行程序（用 trace生成工具或快速模拟器），得到每个样本中所有基本块执行次数所构成的基本块矢量（BBV)，并根据 BBV的相似性通过聚类算法( PCA )把所有样本分成若干类，然后为每类挑选一个样本来做为代表，最后得到一组作为代表的样本。整体的性能由所有代表样本的性能及其权重决定。

单遍多配置算法

举例：运行一次就可以获得多个CACHE 配置（不同大小，不同相联度）的失效率数据

预处理

对trace或者目标可执行程序进行预处理，常常可以减少模拟器运行时的开销  (感觉是编译器工作)

软件缓存

把模拟器重复做的事情缓存起来，加速其运行 （这就是龙芯模拟器1200行的struct出处

并行

关键是要解决预热和误差控制问题

### 误差分析和验证  (以下结论均来自paper)

1.   不针对特定处理器的模拟器，倾向于 高估性能。这通常是因为它没有反映实际硬件中的一些限制条件
2.   针对特定结构设计的模拟器在未经验证之前通常低估性能，因为不容易正确实现
3.   忽略操作系统的影响可能导致高达 100%的误差

### 硅后优化

作用： 改进流片前的性能模型， 优化编译器和操作系统

方法：使用硬件性能计数器，但是乱序处理器不能只看单一指标，可以考虑采样一条指令生命周期的详细数据，或者采样临近指令

## 相关工作介绍

### alpha-sim

trace-driven ，但trace的生成有两种方案

1.   atom 插桩法， 送实际执行的指令，但是没有考虑错误预测的指令，精确度低
2.   aint 指令集解释器，考虑到错误预测路径，能输出 程序执行的拍数、每拍平均执行了多条指令以及功能部件的使用、每种指令类型花在每个主要流水级的拍数、频繁执行的指令序列、分支预测和其它预测的报告、很难预测的指令等等

结论（踩坑）：

1.   模拟器开发早期需要灵活性，相当重要
2.   bpu测试，需要专用模拟器单独追踪分支指令
3.   event-driven不大行，只有35%的时间在这块
4.   基于文本的log调试很有效

### powerPC

trace-driven，trace generate 和 model 分离，两种工作模式

可取之处：

1.   逆向流水线设计
2.   合并中构建不停滞的几个连续流水级
3.   采用单队列最小化流水级间信息交换开销
4.   采样技术
5.   程序设计上：预处理译码，编译时参数化，编译优化

### SimpleScalar

exec-driven, 提供了一套参考模拟器，包括快速的功能模拟器、用于分支预测评估的模拟器、 用于 CACHE 层次评估的模拟器，以及一个详细的超标量多发射处理器微体系结构模拟器，但不针对特定微架构。

只提供单线程、静态链接、用户程序的模拟，用户程序对操作系统的调用是通过一个代理接口（proxy)调用主机操作系统来完成的

### simos

全系统模拟包括外设，支持 指令集模拟器 + 超标量模拟器 + 二进制翻译，调试强大，缺点：不是很开源

### Intel P4

特殊的trace结构，{体系结构状态，内存，外部中断} ，trace由硬件从实际程序中运行得到，模拟时不实际执行遇到的系统调用（因为系统调用的效果不是确定的），而是用踪迹中保存的相关信息重现系统调用的效果，这样可以保证模拟是完全可重现，理解为checkpoint.

性能模型和RTL采用分布式环境交叉验证，所有异常提交到数据库，由专门小组负责，整体比较激进

### SIMICS

著名的商业模拟环境，gem5前身

### RSIM

exec-driven，模拟了超标量处理器、存储层次以及多处理器互连和协议。最终版本ML-RSIM我已经开源

### 龙芯1号

cycle accurate model

踩得坑：

1.   速度太慢，不好改
2.   只关心处理器核，没有考虑实际的系统IO，访存性能，集成性能包括处理器、配套芯片组、操作系统、编译器不理想
3.   性能分析方法和流程来定位性能瓶颈
